
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>&lt;no title&gt; &#8212; pydgilib 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“”“This module provides Python bindings for the Discovery API of DGILib.”“”</p>
<p>__author__ = “Erik Wouters &lt;ehwo(at)kth.se&gt;”
__credits__ = “Atmel Corporation. / Rev.: Atmel-42771A-DGILib_User Guide-09/2016”
__license__ = “MIT”
__version__ = “0.1”
__revision__ = ” $Id: dgilib_discovery.py 1586 2019-02-13 15:56:25Z EWouters $ ”
__docformat__ = “reStructuredText”</p>
<p>GET_STRING_SIZE = 100
NUM_INTERFACES = 10
NUM_CONFIG_IDS = 255
NUM_CALIBRATION = 255
BUFFER_SIZE = 10000000
MAX_PRINT = 100</p>
<p># Interface types
INTERFACE_TIMESTAMP  = 0x00 #   0 Service interface which appends timestamps to all received events on associated interfaces.
INTERFACE_SPI        = 0x20 #  32 Communicates directly over SPI in Slave mode.
INTERFACE_USART      = 0x21 #  33 Communicates directly over USART in Slave mode.
INTERFACE_I2C        = 0x22 #  34 Communicates directly over I2C in Slave mode.
INTERFACE_GPIO       = 0x30 #  48 Monitors and controls the state of GPIO pins.
INTERFACE_POWER_DATA = 0x40 #  64 Receives data from the attached power measurement co-processors.
INTERFACE_POWER_SYNC = 0x41 #  65 Receives sync events from the attached power measurement co-processors.
INTERFACE_RESERVED   = 0xFF # 255 Special identifier used to indicate no interface.</p>
<p># Circuit types
OLD_XAM = 0x00 #   0
XAM     = 0x10 #  16
PAM     = 0x11 #  17
UNKNOWN = 0xFF # 255</p>
<p># Return codes
IDLE               = 0x00 #   0
RUNNING            = 0x01 #   1
DONE               = 0x02 #   2
CALIBRATING        = 0x03 #   3
INIT_FAILED        = 0x10 #  16
OVERFLOWED         = 0x11 #  17
USB_DISCONNECTED   = 0x12 #  18
CALIBRATION_FAILED = 0x20 #  32</p>
<p>from ctypes import *
from time import sleep</p>
<dl class="docutils">
<dt>class DGILibDiscovery(object):</dt>
<dd><p class="first">“”“Python bindings for DGILib Discovery.</p>
<p>DGILib is a Dynamic-Link Library (DLL) to help software applications communicate with Data Gateway
Interface (DGI) devices. See the Data Gateway Interface user guide for further details. DGILib handles
the low-level USB communication and adds a level of buffering for minimizing the chance of overflows.
“”“</p>
<dl class="last docutils">
<dt>def __enter__(self):</dt>
<dd><p class="first">“””
:raises: <code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceIndexError</span></code>
“”“</p>
<p>self.discover()
device_count = self.get_device_count()</p>
<dl class="docutils">
<dt>if self.device_sn is None:</dt>
<dd><dl class="first docutils">
<dt>if self.device_index is None:</dt>
<dd>self.device_index = 0</dd>
<dt>elif self.device_index &gt; device_count - 1:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceIndexError(</dt>
<dd>f”Discovered {device_count} devices so could not select device with index {self.device_index}.”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
<p class="last">self.device_sn = self.get_device_serial(self.device_index)</p>
</dd>
</dl>
<p># UNTESTED:
# if msd_mode:
#     res = self.set_mode(sn, 1)
#     print(f”t{res} set_mode 1”)</p>
<p class="last">return self</p>
</dd>
<dt>def __exit__(self, exc_type, exc_value, traceback):</dt>
<dd><dl class="first docutils">
<dt>if self.verbose:</dt>
<dd>print(“bye from Discovery”)</dd>
</dl>
<p class="last">“”“</p>
</dd>
</dl>
</dd>
</dl>
<p>TODO?
2.1.1. initialize_status_change_notification
Initializes the system necessary for using the status change notification callback mechanisms. A handle
will be created to keep track of the registered callbacks. This function must always be called before
registering and unregistering notification callbacks.
Function definition
void initialize_status_change_notification(uint32_t* handlep)
Parameters
handlep Pointer to a variable that will hold the handle
2.1.2. uninitialize_status_change_notification
Uninitializes the status change notification callback mechanisms. This function must be called when
shutting down to clean up memory allocations.
Function definition
void uninitialize_status_change_notification(uint32_t handle)
Parameters
handle Handle to uninitialize
2.1.3. register_for_device_status_change_notifications
Registers provided function pointer with the device status change mechanism. Whenever there is a
change (device connected or disconnected) the callback will be executed. Note that it is not allowed to
connect to a device in the context of the callback function. The callback function has the following
definition: typedef void (<em>DeviceStatusChangedCallBack)(char</em> device_name, char* device_serial, BOOL
connected)
Function definition
void register_for_device_status_change_notifications(uint32_t handle, DeviceStatusChangedCallBack
deviceStatusChangedCallBack)
Parameters
handle Handle to change notification mechanisms
deviceStatusChangedCallBack Function pointer that will be called when the devices change
2.1.4. unregister_for_device_status_change_notifications
Unregisters previously registered function pointer from the device status change mechanism.
Function definition
void unregister_for_device_status_change_notifications(uint32_t handle, DeviceStatusChangedCallBack
deviceStatusChangedCallBack)
Parameters
handle Handle to change notification mechanisms
deviceStatusChangedCallBack Function pointer that will be removed</p>
<blockquote>
<div><blockquote>
<div>“”“</div></blockquote>
<dl class="docutils">
<dt>def discover(self):</dt>
<dd><p class="first">“”“<cite>discover</cite></p>
<p>Triggers a scan to find available devices in the system. The result will be immediately available through
the <cite>get_device_count</cite>, <cite>get_device_name</cite> and <cite>get_device_serial</cite> functions.</p>
<p><cite>void discover(void)</cite>
“”“</p>
<p class="last">self.dgilib.discover()</p>
</dd>
<dt>def get_device_count(self):</dt>
<dd><p class="first">“”“<cite>get_device_count</cite></p>
<p>Returns the number of devices detected.</p>
<p><cite>int get_device_count(void)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">The number of devices detected</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>device_count = self.dgilib.get_device_count()
if self.verbose:</p>
<blockquote>
<div>print(f”device_count: {device_count}”)</div></blockquote>
<p class="last">return device_count</p>
</dd>
<dt>def get_device_name(self, index):</dt>
<dd><p class="first">“”“<cite>get_device_name</cite></p>
<p>Gets the name of a detected device.</p>
<p><cite>int get_device_name(int index, char* name)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param index:</th><td class="field-body">Index of device ranges from 0 to <cite>get_device_count</cite> - 1</td>
</tr>
<tr class="field-even field"><th class="field-name">type index:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">The name of a detected device</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">str</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>name = create_string_buffer(GET_STRING_SIZE)
res = self.dgilib.get_device_name(index, byref(name))
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} get_device_name: {name.value}”)</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”get_device_name returned: {res}”)</dd>
</dl>
<p class="last">return name.value</p>
</dd>
<dt>def get_device_serial(self, index):</dt>
<dd><p class="first">“”“<cite>get_device_serial</cite></p>
<p>Gets the serial number of a detected device.</p>
<p><cite>int get_device_serial(int index, char* sn)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param index:</th><td class="field-body">Index of device ranges from 0 to <cite>get_device_count</cite> - 1</td>
</tr>
<tr class="field-even field"><th class="field-name">type index:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">The serial number of a detected device</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">str</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>device_sn = create_string_buffer(GET_STRING_SIZE)
res = self.dgilib.get_device_serial(index, byref(device_sn))
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} get_device_serial: {device_sn.value}”)</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”get_device_serial returned: {res}”)</dd>
</dl>
<p class="last">return device_sn.value</p>
</dd>
<dt>def is_msd_mode(self, device_sn):</dt>
<dd><p class="first">“”“<cite>is_msd_mode</cite>
EDBG devices can be set to a mass storage mode where the DGI is unavailable. In such cases the
device is still detected by DGILib, but it won’t be possible to directly connect to it. This command is used
to check if the device is in such a mode.</p>
<p>A non-zero return value indicates that the mode must be changed by <cite>set_mode</cite> before proceeding.</p>
<p><cite>int is_msd_mode(char* sn)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param device_sn:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Serial number of the device to check (defaults to self.device_sn)</td>
</tr>
<tr class="field-even field"><th class="field-name">type device_sn:</th><td class="field-body">str or None</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">A non-zero return value indicates that the mode must be changed by <cite>set_mode</cite> before proceeding.</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>msd_mode = self.dgilib.is_msd_mode(device_sn)
if self.verbose:</p>
<blockquote>
<div>print(f”msd_mode: {msd_mode}”)</div></blockquote>
<p class="last">return msd_mode</p>
</dd>
<dt>def set_mode(self, device_sn, nmbed=1):</dt>
<dd><p class="first">“”“<cite>set_mode</cite>
This function is used to temporarily set the EDBG to a specified mode.</p>
<p><cite>int set_mode(char* sn, int nmbed)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param device_sn:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Serial number of the device to set</td>
</tr>
<tr class="field-even field"><th class="field-name">type device_sn:</th><td class="field-body">str</td>
</tr>
<tr class="field-odd field"><th class="field-name">param nmbed:</th><td class="field-body">0 - Set to mbed mode. 1 - Set to DGI mode (defaults to DGI mode)</td>
</tr>
<tr class="field-even field"><th class="field-name">type nmbed:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.set_mode(device_sn, nmbed)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} set_mode {nmbed}”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”set_mode returned: {res}”)</dd>
</dl>
</dd>
</dl>
</div></blockquote>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pydgilib</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Erik Wouters.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/pydgilib/dgilib_discovery..py.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>