
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>&lt;no title&gt; &#8212; pydgilib 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“”“This module provides Python bindings for the Auxiliary API of DGILib.”“”</p>
<p>__author__ = “Erik Wouters &lt;ehwo(at)kth.se&gt;”
__credits__ = “Atmel Corporation. / Rev.: Atmel-42771A-DGILib_User Guide-09/2016”
__license__ = “MIT”
__version__ = “0.1”
__revision__ = ” $Id: dgilib_auxiliary.py 1586 2019-02-13 15:56:25Z EWouters $ ”
__docformat__ = “reStructuredText”</p>
<p>GET_STRING_SIZE = 100
NUM_INTERFACES = 10
NUM_CONFIG_IDS = 255
NUM_CALIBRATION = 255
BUFFER_SIZE = 10000000
MAX_PRINT = 100</p>
<p># Interface types
INTERFACE_TIMESTAMP  = 0x00 #   0 Service interface which appends timestamps to all received events on associated interfaces.
INTERFACE_SPI        = 0x20 #  32 Communicates directly over SPI in Slave mode.
INTERFACE_USART      = 0x21 #  33 Communicates directly over USART in Slave mode.
INTERFACE_I2C        = 0x22 #  34 Communicates directly over I2C in Slave mode.
INTERFACE_GPIO       = 0x30 #  48 Monitors and controls the state of GPIO pins.
INTERFACE_POWER_DATA = 0x40 #  64 Receives data from the attached power measurement co-processors.
INTERFACE_POWER_SYNC = 0x41 #  65 Receives sync events from the attached power measurement co-processors.
INTERFACE_RESERVED   = 0xFF # 255 Special identifier used to indicate no interface.</p>
<p># Circuit types
OLD_XAM = 0x00 #   0
XAM     = 0x10 #  16
PAM     = 0x11 #  17
UNKNOWN = 0xFF # 255</p>
<p># Return codes
IDLE               = 0x00 #   0
RUNNING            = 0x01 #   1
DONE               = 0x02 #   2
CALIBRATING        = 0x03 #   3
INIT_FAILED        = 0x10 #  16
OVERFLOWED         = 0x11 #  17
USB_DISCONNECTED   = 0x12 #  18
CALIBRATION_FAILED = 0x20 #  32</p>
<p>from ctypes import *
from time import sleep</p>
<p>from pydgilib.dgilib_exceptions import *</p>
<dl class="docutils">
<dt>class DGILibAuxiliary(object):</dt>
<dd><p class="first">“”“Python bindings for DGILib Auxiliary.</p>
<p>DGILib is a Dynamic-Link Library (DLL) to help software applications communicate with Data Gateway
Interface (DGI) devices. See the Data Gateway Interface user guide for further details. DGILib handles
the low-level USB communication and adds a level of buffering for minimizing the chance of overflows.
The library helps parse data streams of high complexity. The timestamp interface is parsed and split into
separate buffers for each data source. The power interface is optionally parsed and calibrated using an
auxiliary API.</p>
<p>## Power
The power interface (as found on some EDBG kits and Power Debugger) uses a protocol stream and
calibration scheme that can be tricky to get right. The data rates are also relatively high and the
calibration procedure could cause issues if not handled efficiently. Therefore some auxiliary functions to
help with this have been made to perform parsing and calibration.
“”“</p>
<dl class="last docutils">
<dt>def __enter__(self):</dt>
<dd>self.power_hndl = self.auxiliary_power_initialize()</dd>
</dl>
</dd>
</dl>
<p>#         self.auxiliary_power_register_buffer_pointers()</p>
<blockquote>
<div><blockquote>
<div>return self</div></blockquote>
<dl class="docutils">
<dt>def __exit__(self, exc_type, exc_value, traceback):</dt>
<dd>self.auxiliary_power_uninitialize()</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>#         self.auxiliary_power_unregister_buffer_pointers()</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>if self.verbose:</dt>
<dd>print(“bye from Auxiliary”)</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>def auxiliary_power_initialize(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_initialize</cite>
Initializes the power parser.</p>
<p><cite>int auxiliary_power_initialize(uint32_t* power_hndl_p, uint32_t dgi_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">Handle of the power parser</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">c_uint()</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>power_hndl = c_uint()</p>
<p>res = self.dgilib.auxiliary_power_initialize(byref(power_hndl), self.dgi_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_initialize”)</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”auxiliary_power_initialize returned: {res}”)</dd>
</dl>
<p class="last">return power_hndl</p>
</dd>
<dt>def auxiliary_power_uninitialize(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_uninitialize</cite>
Uninitializes the power parser.</p>
<p><cite>int auxiliary_power_uninitialize(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.auxiliary_power_uninitialize(self.power_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_uninitialize”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”auxiliary_power_uninitialize returned: {res}”)</dd>
</dl>
</dd>
<dt>def auxiliary_power_register_buffer_pointers(</dt>
<dd>self, channel=0, power_type=0, max_count=BUFFER_SIZE</dd>
<dt>):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_register_buffer_pointers</cite>
Registers a set of pointers to be used for storing the calibrated power data. The buffers can then be
locked by auxiliary_power_lock_data_for_reading, and the data directly read from the specified buffers.
Zero-pointers can be specified to get the buffers allocated within DGILib. This requires the data to be
fetched using auxiliary_power_copy_data.</p>
<p><cite>int auxiliary_power_register_buffer_pointers(uint32_t power_hndl, float* buffer, double* timestamp, size_t*
count, size_t max_count, int channel, int type)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param channel:</th><td class="field-body">Power channel for this buffer: A = 0, B = 1 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">type channel:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param power_type:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Type of power data: Current = 0, Voltage = 1, Range = 2 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type power_type:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param max_count:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Number of samples that can fit into the specified buffers (defaults to BUFFER_SIZE)</td>
</tr>
<tr class="field-even field"><th class="field-name">type max_count:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>self.powerBuffer = (c_float * max_count)()
self.powerTimestamp = (c_double * max_count)()
self.powerCount = c_size_t()</p>
<p>max_count = c_size_t(max_count)
channel = c_int(channel)
power_type = c_int(power_type)</p>
<dl class="docutils">
<dt>res = self.dgilib.auxiliary_power_register_buffer_pointers(</dt>
<dd>self.power_hndl,
byref(self.powerBuffer),
byref(self.powerTimestamp),
byref(self.powerCount),
max_count,
channel,
power_type,</dd>
</dl>
<p>)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_register_buffer_pointers”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_register_buffer_pointers returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def auxiliary_power_unregister_buffer_pointers(self, channel=0, power_type=0):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_unregister_buffer_pointers</cite>
Unregisters the pointers for the specified power channel.</p>
<p><cite>int auxiliary_power_unregister_buffer_pointers(uint32_t power_hndl, int channel, int type)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param channel:</th><td class="field-body">Power channel for this buffer: A = 0, B = 1 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">type channel:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param power_type:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Type of power data: Current = 0, Voltage = 1, Range = 2 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type power_type:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>channel = c_int(channel)
power_type = c_int(power_type)</p>
<dl class="docutils">
<dt>res = self.dgilib.auxiliary_power_unregister_buffer_pointers(</dt>
<dd>self.power_hndl, channel, power_type</dd>
</dl>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} auxiliary_power_unregister_buffer_pointers, channel: {channel.value}, power_type: {power_type.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_unregister_buffer_pointers, channel: {channel.value}, power_type: {power_type.value} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def auxiliary_power_calibration_is_valid(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_calibration_is_valid</cite>
Checks the status of the stored calibration.</p>
<p>Returns true if the calibration is valid, false otherwise. Unity gain and offset will be used.</p>
<p><cite>bool auxiliary_power_calibration_is_valid(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">True if the calibration is valid, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>“”“</p>
<dl class="docutils">
<dt>calibration_is_valid = self.dgilib.auxiliary_power_calibration_is_valid(</dt>
<dd>self.power_hndl</dd>
</dl>
<p>)
if self.verbose:</p>
<blockquote>
<div>print(f”auxiliary_power_calibration_is_valid: {calibration_is_valid}”)</div></blockquote>
<p class="last">return bool(calibration_is_valid)</p>
</dd>
<dt>def auxiliary_power_trigger_calibration(self, circuit_type=XAM):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_trigger_calibration</cite>
Triggers a calibration of the specified type. This can take some time, so use <cite>auxiliary_power_get_status</cite>
to check for completion.</p>
<p><cite>int auxiliary_power_trigger_calibration(uint32_t power_hndl, int type)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param circuit_type:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Type of calibration to trigger (defaults to XAM)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type circuit_type:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>circuit_type = c_int(circuit_type)
res = self.dgilib.auxiliary_power_trigger_calibration(</p>
<blockquote>
<div>self.power_hndl, circuit_type</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_trigger_calibration”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_trigger_calibration returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def auxiliary_power_get_calibration(self, length=NUM_CALIBRATION):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_get_calibration</cite>
Gets the raw calibration read from the tool.</p>
<p><cite>int auxiliary_power_get_calibration(uint32_t power_hndl, uint8_t* data, size_t length)</cite></p>
<p>Note: actually returns the number of calibration samples, not an error if non-zero. The length argument is not used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param length:</th><td class="field-body">Number of raw calibration bytes to fetch. See the DGI documentation for number of bytes. (defaults to NUM_CALIBRATION)</td>
</tr>
<tr class="field-even field"><th class="field-name">type length:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">List of the read raw calibration data</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">List(int)</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>data = (c_ubyte * length)()
length = self.dgilib.auxiliary_power_get_calibration(</p>
<blockquote>
<div>self.power_hndl, byref(data)</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div>print(f”auxiliary_power_get_calibration: {length}”)</div></blockquote>
<dl class="docutils">
<dt>if self.verbose &gt;= 2:</dt>
<dd><dl class="first last docutils">
<dt>for i in range(length):</dt>
<dd>print(f”t{i}:t{data[i]}”)</dd>
</dl>
</dd>
</dl>
<p class="last">return data[:length]</p>
</dd>
<dt>def auxiliary_power_get_circuit_type(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_get_circuit_type</cite>
Gets the type of power circuit.</p>
<p><cite>int auxiliary_power_get_circuit_type(uint32_t power_hndl, int* circuit)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">The circuit type: OLD_XAM = 0x00, XAM = 0x10, PAM = 0x11, UNKNOWN = 0xFF</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>circuit = c_int()
res = self.dgilib.auxiliary_power_get_circuit_type(</p>
<blockquote>
<div>self.power_hndl, byref(circuit)</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_get_circuit_type: {circuit.value}”)</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_get_circuit_type: {circuit.value} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
<p class="last">return circuit.value</p>
</dd>
<dt>def auxiliary_power_get_status(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_get_status</cite>
Gets the status of the power parser.</p>
<p>Return codes
- <cite>IDLE</cite> = 0x00
- <cite>RUNNING</cite> = 0x01
- <cite>DONE</cite> = 0x02
- <cite>CALIBRATING</cite> = 0x03
- <cite>INIT_FAILED</cite> = 0x10
- <cite>OVERFLOWED</cite> = 0x11
- <cite>USB_DISCONNECTED</cite> = 0x12
- <cite>CALIBRATION_FAILED</cite> = 0x20</p>
<p><cite>int auxiliary_power_get_status(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">The status of the power parser:
- <cite>IDLE</cite> = 0x00
- <cite>RUNNING</cite> = 0x01
- <cite>DONE</cite> = 0x02
- <cite>CALIBRATING</cite> = 0x03
- <cite>INIT_FAILED</cite> = 0x10
- <cite>OVERFLOWED</cite> = 0x11
- <cite>USB_DISCONNECTED</cite> = 0x12
- <cite>CALIBRATION_FAILED</cite> = 0x20</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>status = self.dgilib.auxiliary_power_get_status(self.power_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”power_status: {status}”)</div></blockquote>
<p class="last">return status</p>
</dd>
<dt>def auxiliary_power_start(self, mode=0, parameter=0):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_start</cite>
Starts parsing of power data. The power and power sync interfaces are enabled automatically, but note
that it is necessary to start the polling separately. This only starts the parser that consumes data from the
DGILib buffer.</p>
<p><cite>int auxiliary_power_start(uint32_t power_hndl, int mode, int parameter)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param mode:</th><td class="field-body">Sets the mode of capture (defaults to 0)
- 0: continuous capturing which requires the user to periodically consume the data
- 1: oneshot capturing that captures data until the buffer has been read once, has been
filled or the time from the first received sample in seconds equals the specified parameter</td>
</tr>
<tr class="field-even field"><th class="field-name">type mode:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param parameter:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Mode specific (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">type parameter:</th><td class="field-body">int or None</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>mode = c_int(mode)
parameter = c_int(parameter)
res = self.dgilib.auxiliary_power_start(self.power_hndl, mode, parameter)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} auxiliary_power_start, mode: {mode.value}, parameter: {parameter.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_start, mode: {mode.value}, parameter: {parameter.value} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def auxiliary_power_stop(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_stop</cite>
Stops parsing of power data.</p>
<p><cite>int auxiliary_power_stop(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.auxiliary_power_stop(self.power_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_stop”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”auxiliary_power_stop returned: {res}”)</dd>
</dl>
</dd>
<dt>def auxiliary_power_lock_data_for_reading(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_lock_data_for_reading</cite>
Blocks the parsing thread from accessing all the buffers. This must be called before the user application
code accesses the buffers, or a call to <cite>auxiliary_power_copy_data</cite> is made. Afterwards
<cite>auxiliary_power_free_data</cite> must be called. Minimize the amount of time between locking and freeing to
avoid buffer overflows.</p>
<p><cite>int auxiliary_power_lock_data_for_reading(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.auxiliary_power_lock_data_for_reading(self.power_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_lock_data_for_reading”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”auxiliary_power_lock_data_for_reading returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def auxiliary_power_copy_data(self, channel=0, power_type=0, max_count=BUFFER_SIZE):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_copy_data</cite>
Copies parsed power data into the specified buffer. Remember to lock the buffers first. If the count
parameter is the same as max_count there is probably more data to be read. Do another read to get the
remaining data.</p>
<p><cite>int auxiliary_power_copy_data(uint32_t power_hndl, float* buffer, double* timestamp, size_t* count, size_t
max_count, int channel, int type)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param channel:</th><td class="field-body">Power channel for this buffer: A = 0, B = 1 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">type channel:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param power_type:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Type of power data: Current = 0, Voltage = 1, Range = 2 (defaults to 0)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type power_type:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param max_count:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Maximum number of elements that the buffer can hold (defaults to BUFFER_SIZE)</td>
</tr>
<tr class="field-even field"><th class="field-name">type max_count:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">Tuple of a list of samples and a list of the timestamps for the samples</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">tuple(list(int), list(int))</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p class="last">“”“</p>
</dd>
</dl>
</dd>
</dl>
<p>#         buffer = (c_float * max_count)()
#         timestamp = (c_double * max_count)()</p>
<blockquote>
<div><p>count = c_size_t()
max_count = c_size_t(max_count)
channel = c_int(channel)
power_type = c_int(power_type)</p>
<dl class="docutils">
<dt>res = self.dgilib.auxiliary_power_copy_data(</dt>
<dd>self.power_hndl,
self.powerBuffer,
self.powerTimestamp,</dd>
</dl>
</div></blockquote>
<p>#             byref(self.powerCount),
#             buffer,
#             timestamp,</p>
<blockquote>
<div><blockquote>
<div>byref(count),
max_count,
channel,
power_type,</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} auxiliary_power_copy_data: {count.value} samples, power_type: {power_type.value}”</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>#                 f”t{res} auxiliary_power_copy_data: {self.powerCount.value} samples, power_type: {power_type.value}”</dt>
<dd><blockquote class="first">
<div>)</div></blockquote>
<dl class="last docutils">
<dt>if self.verbose &gt;= 3:</dt>
<dd>for i in range(min(count.value, MAX_PRINT)):</dd>
</dl>
</dd>
</dl>
<p>#             for i in range(min(self.powerCount.value, MAX_PRINT)):
#                 print(f”t{i}: buffer: {buffer[i]}, timestamp: {timestamp[i]}”)</p>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{i}: buffer: {self.powerBuffer[i]}, timestamp: {self.powerTimestamp[i]}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”auxiliary_power_copy_data returned: {res}”)</dd>
</dl>
<p>return self.powerBuffer[: count.value], self.powerTimestamp[: count.value]</p>
</div></blockquote>
<p>#         return self.powerBuffer[:self.powerCount.value], self.powerTimestamp[:self.powerCount.value]
#         return buffer[:], timestamp[:]</p>
<blockquote>
<div><dl class="docutils">
<dt>def auxiliary_power_free_data(self):</dt>
<dd><p class="first">“”“<cite>auxiliary_power_free_data</cite>
Clears the power data buffers and allows the power parser to continue.</p>
<p><cite>int auxiliary_power_free_data(uint32_t power_hndl)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.auxiliary_power_free_data(self.power_hndl)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} auxiliary_power_free_data”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”auxiliary_power_free_data returned: {res}”)</dd>
</dl>
</dd>
</dl>
</div></blockquote>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pydgilib</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Erik Wouters.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/pydgilib/dgilib_auxiliary..py.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>