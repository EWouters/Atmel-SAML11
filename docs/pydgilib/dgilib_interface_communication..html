
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>&lt;no title&gt; &#8212; pydgilib 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“”“This module provides Python bindings for the Interface Communication API of DGILib.”“”</p>
<p>__author__ = “Erik Wouters &lt;ehwo(at)kth.se&gt;”
__credits__ = “Atmel Corporation. / Rev.: Atmel-42771A-DGILib_User Guide-09/2016”
__license__ = “MIT”
__version__ = “0.1”
__revision__ = (</p>
<blockquote>
<div>” $Id: dgilib_interface_communication.py 1586 2019-02-13 15:56:25Z EWouters $ “</div></blockquote>
<p>)
__docformat__ = “reStructuredText”</p>
<p>GET_STRING_SIZE = 100
NUM_INTERFACES = 10
NUM_CONFIG_IDS = 255
NUM_CALIBRATION = 255
BUFFER_SIZE = 10000000
MAX_PRINT = 100</p>
<p># Interface types
INTERFACE_TIMESTAMP  = 0x00 #   0 Service interface which appends timestamps to all received events on associated interfaces.
INTERFACE_SPI        = 0x20 #  32 Communicates directly over SPI in Slave mode.
INTERFACE_USART      = 0x21 #  33 Communicates directly over USART in Slave mode.
INTERFACE_I2C        = 0x22 #  34 Communicates directly over I2C in Slave mode.
INTERFACE_GPIO       = 0x30 #  48 Monitors and controls the state of GPIO pins.
INTERFACE_POWER_DATA = 0x40 #  64 Receives data from the attached power measurement co-processors.
INTERFACE_POWER_SYNC = 0x41 #  65 Receives sync events from the attached power measurement co-processors.
INTERFACE_RESERVED   = 0xFF # 255 Special identifier used to indicate no interface.</p>
<p># Circuit types
OLD_XAM = 0x00 #   0
XAM     = 0x10 #  16
PAM     = 0x11 #  17
UNKNOWN = 0xFF # 255</p>
<p># Return codes
IDLE               = 0x00 #   0
RUNNING            = 0x01 #   1
DONE               = 0x02 #   2
CALIBRATING        = 0x03 #   3
INIT_FAILED        = 0x10 #  16
OVERFLOWED         = 0x11 #  17
USB_DISCONNECTED   = 0x12 #  18
CALIBRATION_FAILED = 0x20 #  32</p>
<p>from ctypes import *
from time import sleep</p>
<p>from pydgilib.dgilib_exceptions import *</p>
<dl class="docutils">
<dt>class DGILibInterfaceCommunication(object):</dt>
<dd><p class="first">“”“Python bindings for DGILib Interface Communication.</p>
<p>DGILib is a Dynamic-Link Library (DLL) to help software applications communicate with Data Gateway
Interface (DGI) devices. See the Data Gateway Interface user guide for further details. DGILib handles
the low-level USB communication and adds a level of buffering for minimizing the chance of overflows.
The library helps parse data streams of high complexity. The timestamp interface is parsed and split into
separate buffers for each data source.
“”“</p>
<dl class="last docutils">
<dt>def interface_list(self):</dt>
<dd><p class="first">“”“<cite>interface_list</cite>
Queries the connected DGI device for available interfaces. Refer to the DGI documentation to resolve the
ID.</p>
<p><cite>int interface_list(uint32_t dgi_hndl, unsigned char* interfaces, unsigned char* count)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">List of available interfaces</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">list(int)</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>interfaces = (c_ubyte * NUM_INTERFACES)()
interfaceCount = c_ubyte()
res = self.dgilib.interface_list(</p>
<blockquote>
<div>self.dgi_hndl, byref(interfaces), byref(interfaceCount)</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} interface_list: {interfaces[:interfaceCount.value]}, interfaceCount: {interfaceCount.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”interface_list returned: {res}”)</dd>
</dl>
<p class="last">return interfaces[: interfaceCount.value]</p>
</dd>
<dt>def interface_enable(self, interface_id, timestamp=True):</dt>
<dd><p class="first">“”“<cite>interface_enable</cite>
Enables the specified interface. Note that no data acquisition will begin until a session has been started.</p>
<p><cite>int interface_enable(uint32_t dgi_hndl, int interface_id, bool timestamp)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface to enable</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param timestamp:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Setting this to true will make the interface use timestamping (defaults to True)</td>
</tr>
<tr class="field-even field"><th class="field-name">type timestamp:</th><td class="field-body">bool</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.interface_enable(self.dgi_hndl, interface_id, timestamp)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} interface_enable: {interface_id}, timestamp: {timestamp}”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”interface_enable: {interface_id}, timestamp: {timestamp} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def interface_disable(self, interface_id):</dt>
<dd><p class="first">“”“<cite>interface_disable</cite>
Disables the specified interface.</p>
<p><cite>int interface_disable(uint32_t dgi_hndl, int interface_id)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface to disable</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.interface_disable(self.dgi_hndl, interface_id)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} interface_disable: {interface_id}”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”interface_disable returned: {res}”)</dd>
</dl>
</dd>
<dt>def interface_get_configuration(self, interface_id):</dt>
<dd><p class="first">“”“<cite>interface_get_configuration</cite>
Gets the configuration associated with the specified interface. Consult the DGI documentation for details.</p>
<p><cite>int interface_get_configuration(uint32_t dgi_hndl, int interface_id, unsigned int* config_id, unsigned int*
config_value, unsigned int* config_cnt)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">Tuple of a list of configuration IDs and a list of configuration values</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">tuple(list(int), list(int))</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>config_id = (c_uint * NUM_CONFIG_IDS)()
config_value = (c_uint * NUM_CONFIG_IDS)()
config_cnt = c_uint()
res = self.dgilib.interface_get_configuration(</p>
<blockquote>
<div>self.dgi_hndl,
interface_id,
byref(config_id),
byref(config_value),
byref(config_cnt),</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} interface_get_configuration: {interface_id}, config_cnt: {config_cnt.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="docutils">
<dt>if self.verbose &gt;= 2:</dt>
<dd><dl class="first last docutils">
<dt>for i in range(config_cnt.value):</dt>
<dd>print(f”ttconfig_id: {config_id[i]},tvalue: {config_value[i]}”)</dd>
</dl>
</dd>
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”interface_get_configuration: {interface_id}, timestamp: {timestamp} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
<p class="last">return config_id[: config_cnt.value], config_value[: config_cnt.value]</p>
</dd>
<dt>def interface_set_configuration(self, interface_id, config_id, config_value):</dt>
<dd><p class="first">“”“<cite>interface_set_configuration</cite>
Sets the given configuration fields for the specified interface. Consult the DGI documentation for details.</p>
<p><cite>int interface_set_configuration(uint32_t dgi_hndl, int interface_id, unsigned int* config_id, unsigned int*
config_value, unsigned int config_cnt)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param config_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">List that holds the ID field for the configuration items to set</td>
</tr>
<tr class="field-even field"><th class="field-name">type config_id:</th><td class="field-body">list(int)</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param config_value:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">List that holds the value field for the configuration items to set (must have the same
number of elements as config_id)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type config_value:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">list(int)</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceArgumentError</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<dl class="docutils">
<dt>if len(config_id) == len(config_value):</dt>
<dd>config_cnt = c_uint(len(config_id))</dd>
<dt>else:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceArgumentError(</dt>
<dd>f”interface_set_configuration: the lenght of config_id list ({len(config_id)}) is not equal to the lenght of config_value list ({len(config_value)})”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
<p>config_id = (c_uint * NUM_CONFIG_IDS)(<a href="#id1"><span class="problematic" id="id2">*</span></a>config_id)
config_value = (c_uint * NUM_CONFIG_IDS)(<a href="#id3"><span class="problematic" id="id4">*</span></a>config_value)
res = self.dgilib.interface_set_configuration(</p>
<blockquote>
<div>self.dgi_hndl,
interface_id,
byref(config_id),
byref(config_value),
config_cnt,</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} interface_set_configuration: {interface_id}, config_cnt: {config_cnt.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="last docutils">
<dt>if self.verbose &gt;= 2:</dt>
<dd><dl class="first last docutils">
<dt>for i in range(config_cnt.value):</dt>
<dd>print(f”ttconfig_id: {config_id[i]},tvalue: {config_value[i]}”)</dd>
</dl>
</dd>
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”interface_set_configuration: {interface_id} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
<dt>def interface_clear_buffer(self, interface_id):</dt>
<dd><p class="first">“”“<cite>interface_clear_buffer</cite>
Clears the data in the buffers for the specified interface.</p>
<p><cite>int interface_clear_buffer(uint32_t dgi_hndl, int interface_id)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>res = self.dgilib.interface_clear_buffer(self.dgi_hndl, interface_id)
if self.verbose:</p>
<blockquote>
<div>print(f”t{res} interface_clear_buffer: {interface_id}”)</div></blockquote>
<dl class="last docutils">
<dt>if res:</dt>
<dd>raise DeviceReturnError(f”interface_clear_buffer returned: {res}”)</dd>
</dl>
</dd>
<dt>def interface_read_data(self, interface_id):</dt>
<dd><p class="first">“”“<cite>interface_read_data</cite>
Reads the data received on the specified interface. This should be called regularly to avoid overflows in
the system. DGILib can buffer 10M samples.</p>
<p><cite>int interface_read_data(uint32_t dgi_hndl, int interface_id, unsigned char* buffer, unsigned long long*
timestamp, int* length, unsigned int* ovf_index, unsigned int* ovf_length, unsigned int* ovf_entry_count)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">Tuple of a list of received values and a list of ticks</td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body">tuple(list(int), list(int))</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>buffer = (c_ubyte * BUFFER_SIZE)()
ticks = (c_ulonglong * BUFFER_SIZE)()
length = c_uint(0)
ovf_index = c_uint(0)
ovf_length = c_uint(0)
ovf_entry_count = c_uint(0)
res = self.dgilib.interface_read_data(</p>
<blockquote>
<div>self.dgi_hndl,
interface_id,
buffer,
ticks,
byref(length),
byref(ovf_index),
byref(ovf_length),
byref(ovf_entry_count),</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} interface_read_data: {interface_id}, length: {length.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="docutils">
<dt>if self.verbose &gt;= 2:</dt>
<dd><dl class="first last docutils">
<dt>for i in range(length.value):</dt>
<dd>print(f”t{i}:tbuffer: {buffer[i]},ttick: {ticks[i]}”)</dd>
</dl>
</dd>
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”interface_read_data: {interface_id} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
<p class="last">return buffer[: length.value], ticks[: length.value]</p>
</dd>
<dt>def interface_write_data(self, interface_id, buffer):</dt>
<dd><p class="first">“”“<cite>interface_write_data</cite>
Writes data to the specified interface. A maximum of 255 elements can be written each time. An error
return code will be given if data hasn’t been written yet.</p>
<p>TODO: A non-zero return value indicates an error. An error will be returned if the interface is still in the process of
writing data. Wait a while and try again. The function get_connection_status can be used to verify if there
is an error condition.</p>
<p><cite>int interface_write_data(uint32_t dgi_hndl, int interface_id, unsigned char* buffer, int* length)</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param interface_id:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">The ID of the interface</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type interface_id:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">param buffer:</th><td class="field-body">Buffer that holds the data to write (defaults to None)</td>
</tr>
<tr class="field-even field"><th class="field-name">type buffer:</th><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeviceReturnError</span></code></td>
</tr>
</tbody>
</table>
<p>“”“</p>
<p>length = c_uint(len(buffer))
buffer = (c_ubyte * BUFFER_SIZE)(<a href="#id5"><span class="problematic" id="id6">*</span></a>buffer)
res = self.dgilib.interface_write_data(</p>
<blockquote>
<div>self.dgi_hndl, interface_id, byref(buffer), byref(length)</div></blockquote>
<p>)
if self.verbose:</p>
<blockquote>
<div><dl class="docutils">
<dt>print(</dt>
<dd>f”t{res} interface_write_data: {interface_id}, length: {length.value}”</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="last docutils">
<dt>if self.verbose &gt;= 2:</dt>
<dd><dl class="first last docutils">
<dt>for i in range(length.value):</dt>
<dd>print(f”t{i}:tbuffer: {buffer[i]}”)</dd>
</dl>
</dd>
<dt>if res:</dt>
<dd><dl class="first docutils">
<dt>raise DeviceReturnError(</dt>
<dd>f”TODOTODOTODO: interface_write_data: {interface_id} returned: {res}”</dd>
</dl>
<p class="last">)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pydgilib</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Erik Wouters.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/pydgilib/dgilib_interface_communication..py.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>