/*
 * aes_interface.c
 *
 * Created: 05/02/2019 14:22:11
 *  Author: Erik
 */ 

#include <atmel_start.h>
//#include "driver_init.h"
//#include "stdio_start.h"

#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include <string.h>

#include "aes_interface.h"

void generate_aes_key(unsigned char * key1) 
{
	mbedtls_ctr_drbg_context ctr_drbg;
	mbedtls_entropy_context entropy;
	unsigned char key[32];

	char *pers = "power measurement Ui1hu6oOCY";
	//char *pers = "aes generate key";
	int ret;
	
	mbedtls_entropy_init( &entropy );

	mbedtls_ctr_drbg_init( &ctr_drbg );

	if( ( ret = mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
	(unsigned char *) pers, strlen( pers ) ) ) != 0 )
	{
		printf( " failed\n ! mbedtls_ctr_drbg_init returned -0x%04x\n", -ret );
		//goto exit;
		return;
	}

	if( ( ret = mbedtls_ctr_drbg_random( &ctr_drbg, key, 32 ) ) != 0 )
	{
		printf( " failed\n ! mbedtls_ctr_drbg_random returned -0x%04x\n", -ret );
		//goto exit;
		return;
	}

}

int test_aes(void)
{
	mbedtls_aes_context aes;
		
	unsigned char key[32] = {
		0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
		0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
	//unsigned char key[32];
	//generate_aes_key(key);
		
	unsigned char iv[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
	unsigned char iv2[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
		
	unsigned char input[64] = {
		0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
		0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
		0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
		0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
	unsigned char encrypted_expected[64] = {
		0xce, 0x05, 0x4c, 0xfa, 0x6e, 0xc2, 0x64, 0xde, 0x70, 0x20, 0x2e, 0x90, 0x6b, 0xd5, 0x70, 0x65,
		0x10, 0x1d, 0xa5, 0x49, 0xb9, 0x84, 0xee, 0x26, 0xaf, 0x6e, 0x06, 0xef, 0x80, 0xfe, 0x30, 0xb3,
		0x49, 0x34, 0x31, 0xa2, 0x14, 0x54, 0x39, 0x1a, 0xc1, 0x1a, 0x1f, 0xf5, 0xdc, 0x04, 0x14, 0xb6,
		0x07, 0xd9, 0x32, 0xea, 0xec, 0x04, 0x46, 0x52, 0x1c, 0x3e, 0xbb, 0x52, 0xb7, 0xd3, 0x8f, 0x4c };
	unsigned char encrypted[64];
	unsigned char output[64];
		
	printf("key:\t\t");
	phex(key, 32);
	printf("iv:\t\t");
	phex(iv, 16);
		
	mbedtls_aes_setkey_enc( &aes, key, 256 );
	mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 64, iv, input, encrypted);
	//printf("iv: ");
	//phex(iv, 16);
	mbedtls_aes_setkey_dec( &aes, key, 256 );
	mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_DECRYPT, 64, iv2, encrypted, output);
	//printf("iv: ");
	//phex(iv2, 16);
	
	printf("input:\t\t");
	phex(input, 64);
	printf("encrypted_ex:\t");
	phex(encrypted_expected, 64);
	printf("encrypted:\t");
	phex(encrypted, 64);
	printf("output:\t");
	phex(output, 64);
		
	printf("CBC encrypt:\t");
	if (0 == memcmp((unsigned char*) encrypted, (unsigned char*) encrypted_expected, 64)) {
		printf("SUCCESS!\n");
	} else {
		printf("FAILURE!\n");
		return ERR_FAILURE;
	}
		
	printf("CBC decrypt:\t");
	if (0 == memcmp((char*) output, (char*) input, 64)) {
		printf("SUCCESS!\n");
	} else {
		printf("FAILURE!\n");
		return ERR_FAILURE;
	}
	
	return ERR_NONE;
}

//int aes_encrypt_in_place(mbedtls_aes_context *ctx)
//{
	//return ERR_NONE;
//}
//
//int aes_decrypt_in_place(mbedtls_aes_context *ctx)
//{
	//return ERR_NONE;
//}

// prints string as hex
void phex(unsigned char * str, unsigned char len)
{
    for (unsigned char i = 0; i < len; ++i)
        printf("%.2x", str[i]);
    printf("\n");
}